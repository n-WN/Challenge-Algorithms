from sage.all import EllipticCurve, Integer, Zmod, xgcd


def long_to_bytes(n: int) -> bytes:
    if n == 0:
        return b"\x00"
    length = (n.bit_length() + 7) // 8
    return n.to_bytes(length, "big")


def derive_modulus(points, multiplier):
    """Recover modulus N using a single resultant relation."""
    residues = [y * y - x * x * x for x, y in points]
    x_vals = [pt[0] for pt in points]
    value = (residues[0] - residues[1]) * (x_vals[0] - x_vals[2]) - (residues[0] - residues[2]) * (x_vals[0] - x_vals[1])
    return Integer(multiplier).gcd(Integer(value))


gift = Integer(10954621221812651197619957228527372749810730943802288293715079353550311138677754821746522832935330138708418986232770630995550582619687239759917418738050269898943719822278514605075330569827210725314869039623167495140328454254640051293396463956732280673238182897228775094614386379902845973838934549168736103799539422716766688822243954145073458283746306858717624769112552867126607212724068484647333634548047278790589999183913)
e1 = Integer(516257683822598401)
e2 = Integer(391427904712695553)
e3 = Integer(431785901506020973)
C1 = (Integer(1206929895217993244310816423179846824808172528120308055773133254871707902120929022352908110998765937447485028662679732041),
      Integer(652060368795242052052268674691241294013033011634464089331399905627588366001436638328894634036437584845563026979258880828))
C2 = (Integer(1819289899794579183151870678118089723240127083264590266958711858768481876209114055565064148870164568925012329554392844153),
      Integer(1110245535005295568283994217305072930348872582935452177061131445872842458573911993488746144360725164302010081437373324551))
C3 = (Integer(1112175463080774353628562547288706975571507012326470665917118873336738873653792420189391867408691423887642725415133046354),
      Integer(1820636035485820691083758790204536675748006232767111209985774382700260408550258280489088658228739971137550264759084468620))

points = [C1, C2, C3]
N = derive_modulus(points, gift)
if not N:
    raise RuntimeError("Failed to recover modulus N")

F = Zmod(N)
residues = [F(y) ** 2 - F(x) ** 3 for x, y in points]
xs = [F(pt[0]) for pt in points]

a = (residues[0] - residues[1]) * (xs[0] - xs[1]).inverse()
b = residues[0] - a * xs[0]

curve = EllipticCurve(F, [a, b])
E_points = [curve(pt) for pt in points]

g, s, t = xgcd(e1, e3)
if g != 1:
    raise ValueError("e1 and e3 must be coprime")
base_point = s * E_points[0] + t * E_points[2]
assert e1 * base_point == E_points[0]
assert e3 * base_point == E_points[2]
assert e2 * base_point == E_points[1]

plaintext = Integer(base_point[0]) >> 8
flag_inner = long_to_bytes(int(plaintext)).decode()
print(f"DASCTF{{{flag_inner}}}")
