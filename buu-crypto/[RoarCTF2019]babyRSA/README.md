# RoarCTF 2019 babyRSA 中文 Write-up

## 题目概述
本题给出生成密钥的脚本 `attachment.py`，脚本通过三次调用 `myGetPrime()` 生成素数 $p,q,r$，随后在模数 $n = pqr$ 下使用公开指数 $e = 0x1001$ 对 flag 做 RSA 加密，得到密文 $c$。我们拿到的公开信息包含 $(n,e,c)$ 以及两组中间变量 $(A_1,B_1)$ 和 $(A_2,B_2)$，需要逆向还原密钥并解密。

## 脚本结构分析
`myGetPrime()` 的逻辑如下：
1. 通过未知的 `getPrime(513)` 随机生成 513 比特素数 $A$；
2. 随机选取 $t \in [10^3, 10^5]$，设 $B = A - t$；
3. 返回 $\operatorname{nextPrime}\big((B!) \bmod A\big)$。

因此输出仅依赖于 $(A,B)$ 和 `nextPrime` 的实现。题目虽然没有给出第三次调用的 $(A_3,B_3)$，但一旦前两次的素数 $p,q$ 被还原，剩下的因子可以直接用 $r = n/(pq)$ 求出。

## 数学推导：高效计算 $B! \bmod A$
我们需要在模 $A$ 下求 $B!$。因为 $A$ 是素数，可以使用 Wilson 定理：$(A-1)! \equiv -1 \pmod{A}$。设 $k = A - B$，那么 $k$ 的取值在 $[10^3,10^5]$，规模很小。

我们将 $(A-1)!$ 拆开：
$$
(A-1)! = B! \times (B+1) \times (B+2) \times \cdots \times (A-1).
$$
利用 $B = A - k$ 将尾积改写成关于 $k$ 的表达式：
$$
(A-1)! = B! \times \prod_{i=1}^{k-1}(A-k+i).
$$
对每一个因子在模 $A$ 下化简，有 $A-k+i \equiv -(k-i) \pmod{A}$，于是
$$
(A-1)! \equiv B! \times (-1)^{k-1} \prod_{i=1}^{k-1} i = B! \times (-1)^{k-1} (k-1)! \pmod{A}.
$$
结合 Wilson 定理即可得到：
$$
B! \equiv (-1)^k \big((k-1)!\big)^{-1} \pmod{A}.
$$
这里的逆元一定存在，因为 $A$ 为素数且 $(k-1)!$ 与 $A$ 互质。算法实现上，只需要遍历 $1$ 到 $k-1$ 并在模 $A$ 下累乘，再调用 Python 内置的 `pow(value, -1, A)` 求逆，复杂度约为 $O(k)$，计算量可控。

## 尝试过程记录
- **第一次尝试（失败）：** 直接调用 `sympy.nextprime()` 来模拟 `nextPrime`。然而受限环境既没有安装 `sympy`，又不允许在 `/tmp` 写缓存，Python 解释器启动时就报错退出。
- **替代方案探索：** 考虑自己实现 Miller–Rabin 素性测试与一个 `next_prime` 循环。然而这在受限环境中仍需额外代码，并且存在实现错误的风险。
- **最终方案：** 利用 $n$ 的存在直接回推出素因子：只需要从 $x = B! \bmod A$ 开始向上扫描整数，计算 $\gcd(x+i, n)$，一旦出现非平凡因子（大于 $1$ 且小于当前模数）就找到了真正的素因子。

## 利用 $\gcd$ 扫描还原素数
记 $x = B! \bmod A$，那么真实的素数为 `nextPrime(x)`，也必然整除 $n$。于是计算流程如下：
1. 设 $candidate = x + 1$；
2. 计算 $g = \gcd(candidate, N)$，其中 $N$ 为当前剩余的模数；
3. 若 $1 < g < N$ 则 $g$ 即为所需素数；否则令 $candidate += 1$ 继续循环。

在实际运行中，两个素数的间隔都只有几十以内，所以扫描非常迅速。按照顺序处理 $(A_1,B_1)$ 得到 $p$，更新 $N = N/p$；再处理 $(A_2,B_2)$ 得到 $q$；最后 $r = N/q$ 自然露出。为了稳妥，还使用 Miller–Rabin 验证了 $r$ 的素性。

## 结果校验与解密
成功提取的素数如下：
- $p = 1276519424397216455160791032620569392845781005616561979809403385593761615670426423039762716291920053306063214548359656555809123127361539475238435285654851$
- $q = 13242175493583584108411324143773780862426183382017753129633978933213674770487765387985282956574197274056162861584407275172775868763712231230219112670015751$
- $r = 5057572094237208127867754008134739503717927865750318894982404287656747895573075881186030840558129423864679886646066477437020450654848839861455661385205433$

验证可得 $pqr = n$。随后计算 Euler 函数
$$
\varphi(n) = (p-1)(q-1)(r-1)
$$
并求出私钥指数
$$
 d \equiv e^{-1} \pmod{\varphi(n)}.
$$
再用标准 RSA 解密公式
$$
 m \equiv c^d \pmod{n}
$$
得到十进制明文，把它转换为 ASCII 字符串即可得到 flag。

## 最终解密结果
```
RoarCTF{wm-CongrAtu1ation4-1t4-ju4t-A-bAby-R4A}
```

## 附件与说明
- `solution.py` 实现了上述所有步骤：通过 Wilson 定理计算 $B! \bmod A$，用 $\gcd$ 扫描提取素数，最后解密输出 flag。
- 如果在网络受限或缺乏第三方库的环境中复现，本方法无需额外依赖即可完成解题。
