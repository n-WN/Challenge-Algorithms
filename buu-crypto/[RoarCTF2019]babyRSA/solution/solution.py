#!/usr/bin/env python3
"""Recover the flag from RoarCTF 2019 babyRSA."""
import math

A1 = 21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467234407
B1 = 21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467140596

A2 = 16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858418927
B2 = 16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858351026

N = 85492663786275292159831603391083876175149354309327673008716627650718160585639723100793347534649628330416631255660901307533909900431413447524262332232659153047067908693481947121069070451562822417357656432171870951184673132554213690123308042697361969986360375060954702920656364144154145812838558365334172935931441424096270206140691814662318562696925767991937369782627908408239087358033165410020690152067715711112732252038588432896758405898709010342467882264362733
E = 0x1001
C = 75700883021669577739329316795450706204502635802310731477156998834710820770245219468703245302009998932067080383977560299708060476222089630209972629755965140317526034680452483360917378812244365884527186056341888615564335560765053550155758362271622330017433403027261127561225585912484777829588501213961110690451987625502701331485141639684356427316905122995759825241133872734362716041819819948645662803292418802204430874521342108413623635150475963121220095236776428


def factorial_mod(limit: int, modulus: int) -> int:
    value = 1
    for i in range(1, limit + 1):
        value = (value * i) % modulus
    return value


def recover_prime(A: int, B: int, modulus: int) -> int:
    k = A - B
    tail_fact = factorial_mod(k - 1, A)
    residue = pow(tail_fact, -1, A)
    if k & 1:
        residue = (-residue) % A
    candidate = residue + 1
    while True:
        factor = math.gcd(candidate, modulus)
        if 1 < factor < modulus:
            return factor
        candidate += 1


def main() -> None:
    p = recover_prime(A1, B1, N)
    remaining = N // p
    q = recover_prime(A2, B2, remaining)
    r = remaining // q

    phi = (p - 1) * (q - 1) * (r - 1)
    d = pow(E, -1, phi)
    m = pow(C, d, N)
    flag = m.to_bytes((m.bit_length() + 7) // 8, 'big').decode()
    print(flag)


if __name__ == "__main__":
    main()
