from Crypto.Util.number import inverse, long_to_bytes

# 从题目输出中获取这些值
c1= 36918910341116680090654563538246204134840776220077189276689868322808977412566781872132517635399441578464309667998925236488280867210758507758915311644529399878185776345227817559234605958783077866016808605942558810445187434690812992072238407431218047312484354859724174751718700409405142819140636116559320641695
c2= 15601788304485903964195122196382181273808496834343051747331984997977255326224514191280515875796224074672957848566506948553165091090701291545031857563686815297483181025074113978465751897596411324331847008870832527695258040104858667684793196948970048750296571273364559767074262996595282324974180754813257013752
p= 12101696894052331138951718202838643670037274599483776996203693662637821825873973767235442427190607145999472731101517998719984942030184683388441121181962123
r= 10199001137987151966640837133782537428248507382360655526592866939552984259171772190788036403425837649697437126360866173688083643144865107648483668545682383
e = 31413537523

# 步骤 1 & 2: 在模 p 环境下解密
phi_p = p - 1
dp = inverse(e, phi_p)
mp = pow(c1, dp, p)

# 步骤 3 & 4: 在模 r 环境下解密
phi_r = r - 1
dr = inverse(e, phi_r)
mr = pow(c2, dr, r)

# 步骤 5: 使用中国剩余定理 (CRT) 求解
# 我们需要求解同余方程组:
# m ≡ mp (mod p)
# m ≡ mr (mod r)
#
# 根据 CRT 公式 m = m1*M1*M1_inv + m2*M2*M2_inv (mod N)
# 在这里 N = p*r, M1 = r, M2 = p
# M1_inv = inverse(r, p)
# M2_inv = inverse(p, r)
#
# term1 = mr * p * inverse(p, r)
# term2 = mp * r * inverse(r, p)
# m = (term1 + term2) % (p * r)
# 这是一个标准的 CRT 实现

def chinese_remainder_theorem(remainders, moduli):
    """
    接收两个列表：余数列表和模数列表，返回 CRT 的唯一解。
    """
    if len(remainders) != len(moduli):
        raise ValueError("输入列表长度必须相等")
    
    N = 1
    for n_i in moduli:
        N *= n_i
        
    result = 0
    for r_i, n_i in zip(remainders, moduli):
        N_i = N // n_i
        # 计算 N_i 在模 n_i 下的逆元
        inv_N_i = inverse(N_i, n_i)
        result = (result + r_i * N_i * inv_N_i) % N
        
    return result

# 使用 CRT 函数求解 m
m = chinese_remainder_theorem([mp, mr], [p, r])

# 步骤 6: 将结果转换回字节
plaintext_bytes = long_to_bytes(m)
# plaintext = plaintext_bytes.decode('utf-8')

print("Recovered message:")
print(plaintext)