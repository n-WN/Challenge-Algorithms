# Klepto RSA Write-Up

## 题目概览
给出的脚本结合了常规 RSA 密钥生成与“窃听型”（kleptographic）后门。公开信息包括：

- 一个被泄露的乘积 $Y = P \cdot Q$；
- 高精度实数 $k \approx P/Q$；
- 公钥模数 $n$ 与密文 $c$；
- 生成过程会将随机种子 $s$ 通过 $c_s = s^e \bmod Y$ 嵌入到 $n$ 的高位（`Klepto_RSA_key_generate`）。

攻破思路：利用 $(Y, k)$ 恢复真正的 RSA 素数 $P, Q$，随后逆向还原 klepto 种子 $s$，最终复现模数中隐藏的素数 $p$ 以分解 $n$ 并解密。

## 恢复真实的 $P, Q$
由于泄露了 $Y$ 与精度足够高的 $k$，可以近似求出：
$$
Q \approx \sqrt{\frac{Y}{k}}, \quad P = \frac{Y}{Q}.
$$

在 Python 中使用高精度 `Decimal`，对 $\sqrt{Y/k}$ 四舍五入得到整数 $Q$，再除回 $P$。验算 `P * Q == Y` 与 `P / Q` 接近输入的 $k$，确认恢复成功。

得到的素数：
- $P = 8008772260727629423440445480119071331420614293312513242535642519954131383516651456806928896352473195784711243905415318930712465859575296763243142808530597$；
- $Q = 7497995514388761796822198543462891817538852359670501330119730613642015639686904591577240500641873052388733461405895133192226338138188240045378695956738147$。

## 解出 klepto 种子 $s$
klepto 过程中，生成者先取随机 $s$（1024 位），然后计算：
$$
Y = P Q,\qquad c_s = s^e \bmod Y.
$$
之后 $c_s$ 拼接在 $n$ 的高位。由于模数 $n$ 的高 1024 位正是 $c_s$，我们可以取 `c_est = n >> 1024`，对其执行 RSA 逆变换：
$$
\phi(Y) = (P-1)(Q-1),\qquad d_Y \equiv e^{-1} \bmod \phi(Y),\qquad s_0 = c_{est}^{\,d_Y} \bmod Y.
$$
$ s_0 $ 仍然是模 $Y$ 的代表元。为了恢复原始 $s$，枚举 $s_0 + kY$ 使其成为 1024 位数。实验表明可行的 $k$ 仅有 $1$ 与 $2$，最终验证 $s = s_0 + 2Y$ 才可复现后续素数。

## 分解模数 $n$
得到了正确的 $s$ 后，klepto 代码通过：
$$
\text{seed} = \underbrace{\text{str}(s) \Vert \text{str}(s) \Vert \text{str}(s) \Vert \text{str}(s)}_{\text{字符串拼接}},\qquad
h = \text{SHA256}(\text{seed}),\qquad
p = \text{next\_prime}(h).
$$
我们按同样流程计算 $p$，得到 $n \bmod p = 0$，据此分解出 $n = p q$，并验证两者均为素数。

## 解密
有了 $p, q$ 后，标准 RSA 解密：
$$
\phi(n) = (p-1)(q-1),\qquad d_n \equiv e^{-1} \bmod \phi(n),\qquad m = c^{d_n} \bmod n.
$$
最后将 $m$ 转为字节得到明文。

## 尝试与踩坑记录
- 刚开始直接拿题面给出的 $c$ 与 $Y$ 做幂逆，注意到 $c > Y$ 且缺少与 klepto 过程的对应关系，此路不通。
- 基于错误的 $s$ 提升（使用 $s_0$ 或 $s_0 + Y$）计算出的 $p$ 无法整除 $n$，由此意识到必须匹配 1024 位长度并验证所有可能的补偿倍数。
- 在缺少 `gmpy2` 和 `sympy` 的情况下，改用 `Crypto.Util.number.isPrime` 手写 `next_prime`，虽然慢，但足以在小范围内搜索。
- 后续基于 $30$-轮筛优化了 `next_prime`，先做小素数试除再调用 `isPrime`，极大减少了昂贵的概率素性检测次数。

## 复现脚本
```python
from Crypto.Util.number import long_to_bytes, isPrime
from hashlib import sha256

# 恢复的 P, Q 与参数
P = 8008772260727629423440445480119071331420614293312513242535642519954131383516651456806928896352473195784711243905415318930712465859575296763243142808530597
Q = 7497995514388761796822198543462891817538852359670501330119730613642015639686904591577240500641873052388733461405895133192226338138188240045378695956738147
Y = P * Q
phiY = (P - 1) * (Q - 1)
e = 65537
dY = pow(e, -1, phiY)

# klepto 嵌入的密文高位
n = 3596023580695592789457907802183196756399681015977233295242340936238317018973691599034589854880732384096820035377138261693940394499711123250057901177534616478446934890712142462629287889087402878855602205118569066176847336006999797783812847405621452976590905189308318494920580036460265251370023160444010457343969742500140268145656657584719331223994655918529509324803740906083657280801194613866731974952982345953343515716799498889563560737063361265021629014810595064645026641575740759888841089351365082040998384669205706549841999836035376731041737200044788780457487328828468423385665897008481229300042703829197546732297
c_est = n >> 1024
s_mod = pow(c_est, dY, Y)

# 选择正确的提升倍数
s = s_mod + 2 * Y
seed = (str(s).encode()) * 4

# 自定义 next_prime
candidate = int(sha256(seed).hexdigest(), 16)
def next_prime(x):
    if x < 2:
        return 2
    small_primes = (3, 5, 7, 11, 13, 17, 19, 23, 29)
    candidate = x + 1
    if candidate % 2 == 0:
        candidate += 1
    wheel = (4, 2, 4, 2, 4, 6, 2, 6)
    idx = 0
    while True:
        divisible = False
        for p in small_primes:
            if candidate % p == 0:
                divisible = candidate != p
                break
        if not divisible and isPrime(candidate):
            return candidate
        candidate += wheel[idx]
        idx = (idx + 1) % len(wheel)

p = next_prime(candidate)
q = n // p
phi = (p - 1) * (q - 1)
d = pow(e, -1, phi)

c_flag = 203888967389001610610181601143476417134547238322566249798330454501234719047131239762883296665497911055217805585041450651162745276917488079657459750899771802796714955681333597780415365371810254651462195430523242672381668466268361140273008469445121296185425908790295844531556528841683074107174953571777339913744310027149457799483986132530251645062422885009777650388210633336745992191168809481176500394999589620122461747721066331478829996392011933366508176327335982681077308808332600144583212089054079237839958737870002427686663368647458455780051253327602251757646876642924573210398563421295133998467381134193365066426
flag = long_to_bytes(pow(c_flag, d, n))
print(flag)
```

## Flag
```
DASCTF{W0W_You_know_7he_RSA_Kl3pto}
```
