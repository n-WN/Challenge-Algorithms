# 基于 NTRU

### 1. 问题分析

这是一个在 SageMath 环境中实现的 NTRU 变体。

#### a. 多项式环
题目在两个多项式环上进行运算：
* **$R_q$**: 系数在模 $q=1091$ 整数环 $Z_{1091}$ 上的多项式，并且这些多项式都对 $x^{117} + 1$ 取模。数学上记为 $R_q = \frac{\mathbb{Z}_{1091}[x]}{x^{117}+1}$。这是密文和公钥所在的环。
* **$R_p$**: 系数在模 $p=3$ 整数环 $Z_3$ 上的多项式，同样对 $x^{117} + 1$ 取模。数学上记为 $R_p = \frac{\mathbb{Z}_3[x]}{x^{117}+1}$。这是明文和私钥部分运算所在的环。

#### b. 关键参数
* $n=117$: 多项式的最高次数，定义了环的维度。
* $p=3$: 明文空间的模数。
* $q=1091$: 密文空间的模数，是一个素数。

#### c. 加密过程剖析
服务器的核心加密逻辑在 `encrypt` 函数中：
$$c = pk \cdot r + m$$
我们来分析其中每一个组成部分：
* **$pk$ (公钥)**: 一个在 $R_q$ 环中的多项式。在整个交互过程中，**$pk$ 是固定不变的**。服务器代码确保了生成的 $pk$ 在 $R_q$ 中是可逆的。
* **$m$ (待加密消息)**: 这是一个在 $R_q$ 中的多项式，它由两部分构成：
    $$m = \text{secretPoly} + \text{QR}([\text{round}(i / 3329 * q) \text{ for i in msg}])$$
    * `secretPoly` ($s$): 一个由服务器生成的、我们未知的秘密多项式。它的系数由 $\{1, 0, -1\}$ 组成，并且在整个交互过程中也是**固定不变的**。这是我们最终的目标。
    * `msg`: 这是我们**可以完全控制**的输入部分。我们可以选择 10 次不同的 `msg`。我们将其记为 $m_i^{\text{chosen}}$。
* **$r$ (随机扰动项)**: 一个在 $R_q$ 环中的多项式。`randomPoly` 函数显示，它的系数**完全由0和1组成**。每次调用 `encrypt` 时，服务器都会生成一个**新的、随机的** $r$。我们将第 $i$ 次加密使用的 $r$ 记为 $r_i$。

因此，对于我们发送的第 $i$ 组消息 $m_i^{\text{chosen}}$，服务器实际执行的加密过程可以写为：
$$c_i = pk \cdot r_i + s + m_i^{\text{chosen}}$$
其中 $c_i$ 是服务器返回给我们的第 $i$ 个密文。

### 2. 作差

既然 $pk$ 和 $s$ 在10次加密中都是不变的，而 $m_i^{\text{chosen}}$ 是我们已知的，这就为我们创造了进行代数操作的条件。我们可以通过选取任意两次加密（例如第 $i$ 次和第 $j$ 次）的结果进行作差，来消除未知的秘密 $s$。

考虑第 $i$ 次和第 $j$ 次加密：
$$c_i = pk \cdot r_i + s + m_i^{\text{chosen}}$$
$$c_j = pk \cdot r_j + s + m_j^{\text{chosen}}$$

两式相减，得到：
$$c_i - c_j = (pk \cdot r_i + s + m_i^{\text{chosen}}) - (pk \cdot r_j + s + m_j^{\text{chosen}})$$
$$c_i - c_j = pk \cdot r_i - pk \cdot r_j + s - s + m_i^{\text{chosen}} - m_j^{\text{chosen}}$$
$$c_i - c_j = pk \cdot (r_i - r_j) + (m_i^{\text{chosen}} - m_j^{\text{chosen}})$$

在这个等式中，$c_i, c_j, m_i^{\text{chosen}}, m_j^{\text{chosen}}$ 和 $pk$ 都是已知的。我们可以将已知项移到一边，未知项移到另一边：
$$(c_i - c_j) - (m_i^{\text{chosen}} - m_j^{\text{chosen}}) = pk \cdot (r_i - r_j)$$

因为服务器保证了 $pk$ 在环 $R_q$ 中是可逆的，我们可以计算出 $pk$ 的逆 $pk^{-1}$。在等式两边同时右乘 $pk^{-1}$，即可解出 $r_i - r_j$：
$$\Delta r_{ij} = r_i - r_j = \left( (c_i - c_j) - (m_i^{\text{chosen}} - m_j^{\text{chosen}}) \right) \cdot pk^{-1}$$
这个等式是整个攻击的基石。我们成功地隔离出了与未知随机多项式 $r_i, r_j$ 相关的信息。

### 3. 恢复随机多项式 $r_0$

现在，我们面临的挑战是如何从 $r_i - r_j$ 的差值中恢复出原始的 $r_i$ 或 $r_j$。这里的关键突破口在于 $r_i$ 的特殊结构——它的系数只能是 $0$ 或 $1$。

设 $r_i = \sum_{k=0}^{n-1} a_k x^k$ 且 $r_j = \sum_{k=0}^{n-1} b_k x^k$，其中 $a_k, b_k \in \{0, 1\}$。
那么它们的差 $r_i - r_j$ 的第 $k$ 个系数就是 $a_k - b_k$。这个差值只可能有三种情况：
1.  $1 - 0 = 1$
2.  $0 - 1 = -1$
3.  $1 - 1 = 0$ 或 $0 - 0 = 0$

所以，我们计算出的多项式 $\Delta r_{ij}$ 的系数只能是 $\{1, -1, 0\}$。在模 $q=1091$ 的运算下，$-1$ 会表现为 $1090$。

为了方便起见，我们选择第一次加密的随机多项式 $r_0$ 作为我们的恢复目标。我们利用后续的9次加密，计算出9个差值：
* $\Delta r_{01} = r_0 - r_1$
* $\Delta r_{02} = r_0 - r_2$
* ...
* $\Delta r_{09} = r_0 - r_9$

现在，我们来分析 $\Delta r_{0i}$ 的每一个系数能告诉我们关于 $r_0$ 的什么信息。令 $\Delta r_{0i}$ 的第 $j$ 个系数为 $d_j$， $r_0$ 的第 $j$ 个系数为 $r_{0,j}$，$r_i$ 的第 $j$ 个系数为 $r_{i,j}$。

* **如果 $d_j = 1$**: 这意味着 $r_{0,j} - r_{i,j} = 1$。因为系数只能是0或1，唯一的可能是 $r_{0,j} = 1$ 且 $r_{i,j} = 0$。我们**直接确定了 $r_0$ 的第 $j$ 个系数为 1**。
* **如果 $d_j = -1$ (即 1090)**: 这意味着 $r_{0,j} - r_{i,j} = -1$。唯一的可能是 $r_{0,j} = 0$ 且 $r_{i,j} = 1$。我们**直接确定了 $r_0$ 的第 $j$ 个系数为 0**。
* **如果 $d_j = 0$**: 这意味着 $r_{0,j} - r_{i,j} = 0$。这说明 $r_{0,j} = r_{i,j}$ (要么都为0，要么都为1)。仅凭这一次作差，我们无法确定 $r_{0,j}$ 的值。

**综合信息**:
我们有9个 $\Delta r_{0i}$ 多项式。对于 $r_0$ 的每一个系数位 $j$，我们遍历这9个差值多项式。
* 只要其中**任意一个** $\Delta r_{0i}$ 在第 $j$ 位上的系数是 $1$ 或 $-1$，我们就能确定 $r_{0,j}$ 的值。
* 只有当**所有九个** $\Delta r_{0i}$ 在第 $j$ 位上的系数都为 $0$ 时，我们才无法确定。这种情况发生的概率极低，因为它要求 $r_1, r_2, ..., r_9$ 在第 $j$ 位的系数必须全部与 $r_0$ 的相同。对于随机生成的 $r_i$，这个概率是 $(1/2)^9$。
因此，通过综合9次作差的结果，我们有极大的概率可以完整地恢复出 $r_0$ 的所有117个系数。EXP 中的 `r0` 列表就是用来存储恢复出的系数。

### 4. 解出秘密 $s$ 并获取 Flag

一旦我们成功恢复了 $r_0$，剩下的步骤就非常直接了。

#### a. 计算秘密多项式 $s$
回到第一次加密的原始方程：
$$c_0 = pk \cdot r_0 + s + m_0^{\text{chosen}}$$
将 $s$ 之外的所有项移到另一边：
$$s = c_0 - m_0^{\text{chosen}} - pk \cdot r_0$$
由于 $c_0$, $m_0^{\text{chosen}}$, $pk$, 以及我们刚刚恢复的 $r_0$ 全都是已知的，我们可以直接计算出秘密多项式 $s$。

#### b. 格式化秘密 $s$
计算出的 $s$ 是在 $R_q$ (模1091) 环中的。但是题目提示 `secretPoly` 是 "在模3下 balance 过的"，即其系数为 $\{-1, 0, 1\}$。我们需要将我们计算出的 $s$ 的系数进行转换：
* 系数 $1 \rightarrow 1$
* 系数 $0 \rightarrow 0$
* 系数 $1090 \rightarrow -1$

> 这里的系数 $1090$ 是因为在模 $1091$ 的运算中，$-1 \equiv 1090 \pmod{1091}$。

在 EXP 中，这一步是通过 `if(i == 1090): ss.append(2)` 实现的，因为在模3的运算中， $2 \equiv -1 \pmod 3$。

#### c. 将多项式转换为整数
最后一步是将恢复出的系数为 $\{-1, 0, 1\}$ 的多项式 $s$ 转换回原始的 `secret` 字节串。

`MsgtoPoly` 函数的实现告诉我们这个转换关系：`msg = Integer(bytes_to_long(msg)); m = msg.digits(p)`。

这是一个标准的**基为 $p=3$ 的展开**。

因此，我们要做的就是这个过程的逆运算。设恢复出的 $s$ 为 $s(x) = \sum_{i=0}^{116} s_i x^i$，其中 $s_i \in \{-1, 0, 1\}$。
对应的整数值为：
$$
\text{secret\_int} = \sum_{i=0}^{116} (s_i \bmod 3) \cdot 3^i
$$
计算出这个整数后，我们再将其转换为字节串 `long_to_bytes(secret_int)`，这就是最终的答案。将其发送给服务器，即可获得 flag。
