from Crypto.Util.number import long_to_bytes

# 从题目给出的输出中获取已知值
p = 10369378196431054201191159597286549032305055638016223545452015354806104088488963911546484924978294040977832296121112024196640022021990223152532806666631559
e = 65537
c = 27388835612130218840077826837436023653857551692840082862662858020057766886891088270344878641226208642137158892183837121596685004030841697200165597143326602304400023205163831709646742028989455023724511385977743011930918676953102794566297213953449275396354793891191186160422958884959469309947906976313707092335

# 步骤 1 & 2: 计算模 p 域下的私钥 d_p
# phi_p = p - 1
d_p = pow(e, -1, p - 1)
print(f"[*] Calculated d_p (private key for modulus p): {d_p}")

# 步骤 3 & 4: 在模 p 域下解密，直接恢复消息 m
# 由于 m < p, 所以 m_p = m
m = pow(c, d_p, p)
print(f"[*] Recovered message m: {m}")

# 将整数 m 转换回字节串
flag = long_to_bytes(m)
print(f"\n[+] Recovered Flag: {flag.decode()}")
