# 文件 `rsa_p.py` 详细分析

这份脚本实现了一个标准的 RSA 加密流程，但包含一个严重的安全漏洞，使其可以被轻易破解。下面我们将逐步解析代码、分析漏洞并给出解密方法。

## 代码功能概述

该脚本的核心功能如下：

1.  **导入库**: 从 `Crypto.Util.number` 库中导入了处理大数、素数和字节转换的必要函数。
2.  **定义明文**: `flag` 变量是待加密的秘密信息。
3.  **生成 RSA 密钥**:
      * 使用 `getPrime(512)` 生成两个 512 位的随机大素数 `p` 和 `q`。
      * 计算 RSA 模数 $n = p \cdot q$。
      * 选择公钥指数 $e = 65537$，这是一个常用的值。
      * 计算私钥指数 $d$，它是 $e$ 在模 $\phi(n) = (p-1)(q-1)$ 下的乘法逆元，即 $d \equiv e^{-1} \pmod{(p-1)(q-1)}$。
4.  **加密**: 将 `flag` 字节串转换为一个大整数（我们称之为 $m$），然后使用公钥 $(e, n)$ 对其进行加密，计算出密文 $c \equiv m^e \pmod n$。
5.  **输出**:
      * **关键漏洞**: 脚本打印了其中一个素数因子 `p`。
      * 打印了公钥指数 `e`。
      * 打印了加密后的密文 `c`。
      * **注意**: 脚本**没有**打印出完整的模数 `n` 或另一个素数 `q`。

脚本末尾注释中的 `p`, `e`, `c` 值就是一次运行的输出，也是我们需要破解的目标。

## 核心问题分析

标准的 RSA 解密过程是计算 $m \equiv c^d \pmod n$。为了完成这个计算，我们必须知道私钥 `d` 和模数 `n`。

  * 要计算 `d`，我们需要知道欧拉函数值 $\phi(n) = (p-1)(q-1)$。
  * 要计算 $\phi(n)$，我们需要同时知道 `p` 和 `q`。
  * 题目只给了 `p`，没有给 `q` 或 `n`。

因此，我们无法通过常规方法计算出 `d` 和 `n`，标准解密路径被阻断。

## 漏洞与解题思路

**核心漏洞**在于**泄露了素数因子 `p`**。虽然没有 `n` 和 `q`，但仅凭 `p`, `e`, `c` 就足以恢复明文。这利用了模运算的一条基本性质。

加密操作的核心是下面的同余式：
$$c \equiv m^e \pmod n$$
因为 $n = p \cdot q$，所以 $p$ 是 $n$ 的一个因子。根据同余理论，如果一个数模 `n` 等于另一个数，那么它模 `n` 的任何因子（如 `p`）也必然相等。因此，上述关系式可以推导出：
$$c \equiv m^e \pmod p$$
这个新的同余关系只与我们已知的值 `c`, `e`, `p` 以及未知的 `m` 有关，问题被转化为了一个更小、可解的 RSA 问题。

### **解密步骤**

#### **第一步: 在模 `p` 域下工作**

我们不再关心原始的模数 `n`，只关注模 `p` 的世界。首先，我们计算密文 `c` 在模 `p` 下的等价值：

  * $c_p = c \pmod p$

这样，我们的目标就变成了求解 $m$ 满足：
$$c_p \equiv m^e \pmod p$$

#### **第二步: 求解模 `p` 域下的“私钥”**

在这个模 `p` 的 RSA 系统中，公钥是 $(e, p)$。对应的“私钥” $d_p$ 可以通过求解 $e$ 模 $\phi(p)$ 的逆元得到。因为 `p` 是素数，所以 $\phi(p) = p - 1$。
$$d_p \equiv e^{-1} \pmod{p-1}$$
这个 $d_p$ 我们可以直接计算出来。

#### **第三步: 解密得到 $m \pmod p$**

有了“私钥” $d_p$，我们就可以解密 $c_p$ 得到 $m \pmod p$ 的值。我们称之为 $m_p$。
$$m_p \equiv (c_p)^{d_p} \pmod p$$

#### **第四步: 恢复原始消息 `m`**

经过上一步，我们得到了 $m_p = m \pmod p$。现在的问题是，$m_p$ 和原始消息 `m` 是什么关系？

  * `p` 是一个 512 位的素数，其大小约在 $2^{511}$ 到 $2^{512}$ 之间。
  * 消息 `m` 是由 `flag` 字符串转换而来的整数。一个典型的 flag 长度（例如 50 个字符）所占的比特数远小于 512 位（$50 \text{ bytes} = 400 \text{ bits}$）。

因此，我们可以做出一个非常合理的假设：**消息 `m` 的数值远小于素数 `p`**。
$$m < p$$
当 $m < p$ 时，根据模运算的定义，$m \pmod p = m$。
这意味着我们在第三步中计算出的 $m_p$ **就是原始消息 `m` 本身！**

## 完整解密脚本

根据以上推理，我们可以编写如下 Python 脚本来恢复 `flag`。

```python
from Crypto.Util.number import long_to_bytes

# 从题目给出的输出中获取已知值
p = 10369378196431054201191159597286549032305055638016223545452015354806104088488963911546484924978294040977832296121112024196640022021990223152532806666631559
e = 65537
c = 27388835612130218840077826837436023653857551692840082862662858020057766886891088270344878641226208642137158892183837121596685004030841697200165597143326602304400023205163831709646742028989455023724511385977743011930918676953102794566297213953449275396354793891191186160422958884959469309947906976313707092335

# 步骤 1 & 2: 计算模 p 域下的私钥 d_p
# phi_p = p - 1
d_p = pow(e, -1, p - 1)
print(f"[*] Calculated d_p (private key for modulus p): {d_p}")

# 步骤 3 & 4: 在模 p 域下解密，直接恢复消息 m
# 由于 m < p, 所以 m_p = m
m = pow(c, d_p, p)
print(f"[*] Recovered message m: {m}")

# 将整数 m 转换回字节串
flag = long_to_bytes(m)
print(f"\n[+] Recovered Flag: {flag.decode()}")

```

### **运行结果**

运行上述脚本，即可得到解密后的 flag。

## 总结

这个挑战巧妙地利用了 RSA 的数学基础。它通过泄露一个素数因子 `p`，引导解题者放弃在完整的模数 `n` 下进行解密的思路，转而利用 `c \equiv m^e \pmod p` 这一关系，在一个更小的、可控的范围内解决问题。最终的破解依赖于一个关键假设——明文 `m` 小于泄露的素数 `p`，这在 CTF 场景下通常是成立的。