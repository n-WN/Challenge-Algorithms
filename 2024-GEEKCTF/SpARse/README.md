### **残缺的密钥与完整恢复的目标**

### Reference

[2024-GEEKCTF-wp-crypto](https://tangcuxiaojikuai.xyz/post/13f23fc6.html#SpARse)

[Geekcon-CTF-2024-Writeup tanglee](https://blog.tanglee.top/2024/04/25/Geekcon-CTF-2024-Writeup.html#sparse)

#### Useful Tools

[RSA-PEM-Reconstructor](https://github.com/tl2cents/RSA-PEM-Reconstructor)

### **挑战概述**

这道题的核心挑战是恢复一个**严重损坏**的 RSA 私钥。不同于常见的密码学题目只要求解密特定密文，本题要求我们**完整地复原整个 `privkey.pem` 文件**，因为最终的 flag 是该文件的 MD5 哈希值。这意味着私钥的每一个参数——不仅仅是 $d$，还包括 $p, q, d_p, d_q$ 以及 $q^{-1} \pmod p$——都必须被精确地计算出来。

私钥文件采用了常见的 PKCS#1 格式，其内部数据遵循 ASN.1 DER 编码标准。数据的基本结构是一个序列（SEQUENCE），依次包含以下整数：

1.  `version` (版本号，通常为 0)
2.  `n` (模数)
3.  `e` (公钥指数)
4.  `d` (私钥指数)
5.  `p` (素数因子1)
6.  `q` (素数因子2)
7.  `dp` ($d \pmod{p-1}$)
8.  `dq` ($d \pmod{q-1}$)
9.  `coefficient` ($q^{-1} \pmod p$)

### **第一步：解析损坏的私钥**

首先，我们需要评估私钥的损坏程度。PEM 格式的核心是 Base64 编码，其中的 `?` 代表未知的6个比特。一个有效的方法是将这个带 `?` 的 Base64 字符串转换为一个包含 `*` 的比特流，其中 `*` 代表未知比特。

通过对这个比特流按照 ASN.1 结构进行切分，我们得到以下关键信息：

* **`n` (模数)**: 2048比特，**数据完整**。这是我们最重要的已知信息。
* **`e` (公钥指数)**: 缺少最后几个比特，但其值极大概率是标准的 `65537` ($2^{16}+1$)。我们可以先做此假设，后续的计算会验证这一点。
* **`d`, `p`, `q`, `dp`, `dq`**: 每个参数都存在大面积损坏，已知比特占比仅约 30%。然而，重要的是，它们**在所有比特位上都有部分泄露**，尤其是低位比特的泄露相对较多。
* **`coefficient` (`q_inv_p`)**: 完全丢失。

这个局面告诉我们，无法通过单一的攻击（如仅利用 `d` 的高位或 `p` 的低位）来解决问题。我们必须**综合利用所有参数的已知比特**，建立它们之间的关联，逐步缩小未知比特的搜索空间。

### **第二步：关键的数学关系**

攻击的核心是利用 RSA 各参数之间固有的数学联系。让我们从基础公式出发，推导出用于剪枝的等式。

1.  **基础定义**:
    $$n = pq$$
    $$ed \equiv 1 \pmod{\phi(n)} \quad \text{其中 } \phi(n) = (p-1)(q-1)$$

2.  **引入整数变量**:
    同余式在计算中不方便，我们可以将其转换为等式。存在一个整数 $k$，使得：
    $$ed = 1 + k \cdot (p-1)(q-1)$$
    由于 $d < \phi(n)$，可知 $k$ 是一个在 $[1, e-1]$ 范围内的整数。

3.  **CRT 相关参数**:
    同样地，对于 $d_p = d \pmod{p-1}$ 和 $d_q = d \pmod{q-1}$，我们可以引入整数 $k_p$ 和 $k_q$：
    $$ed_p = 1 + k_p(p-1)$$
    $$ed_q = 1 + k_q(q-1)$$
    *这里的推导是：$d \equiv d_p \pmod{p-1} \implies ed \equiv ed_p \pmod{p-1}$。又因为 $ed \equiv 1 \pmod{p-1}$，所以 $ed_p \equiv 1 \pmod{p-1}$，从而得到上述等式。*

4.  **展开与代换**:
    将 $\phi(n)$ 展开得到 $(p-1)(q-1) = pq - p - q + 1 = n - p - q + 1$。代入 $d$ 的等式：
    $$ed = 1 + k(n - p - q + 1)$$
    这个等式连接了所有五个关键的未知变量 `d, p, q` 和已知量 `n, e, k`，它将成为我们后续深度优先搜索（DFS）的核心剪枝条件。

我们现在拥有了四个核心方程，它们构成了我们攻击的基础：
$$
\begin{cases}
n = pq \\
ed = 1 + k(n - p - q + 1) \\
ed_p = 1 + k_p(p-1) \\
ed_q = 1 + k_q(q-1)
\end{cases}
$$
然而，未知数 $k, k_p, k_q$ 仍然是个障碍。在进行大规模搜索前，必须先确定它们的值。

### **第三步：求解 `k`, `kp`, `kq`**

#### **3.1 求解 `k`**

我们利用 $d$ 的高位比特信息来求解 $k$。从 $ed \approx k \cdot \phi(n)$ 和 $\phi(n) \approx n$ 出发，我们得到一个关键的近似关系：
$$d \approx \frac{k \cdot n}{e}$$
由于我们已知 $d$ 的部分高位比特，我们可以进行一次小范围的爆破：
遍历 $k$ 的所有可能值（从 1 到 $e-1$），计算出 $\frac{k \cdot n}{e}$ 的值，并将其高位与已知的 $d$ 的高位进行比较。如果完全匹配，我们就找到了正确的 $k$。

通过执行代码 `sparse_solve_k_kp_kq.py` 的第一部分，我们爆破得到 **`k = 39770`**。

#### **3.2 求解 `kp` 和 `kq`**

求解 $k_p$ 和 $k_q$ 的过程非常巧妙，它利用了模 $e$ 运算将复杂的方程线性化。
将我们的核心方程组全部置于模 $e$ 的算术下：
1.  $ed \equiv 1 + k(p-1)(q-1) \pmod e \implies 0 \equiv 1 + k(p-1)(q-1) \pmod e$
2.  $ed_p \equiv 1 + k_p(p-1) \pmod e \implies 0 \equiv 1 + k_p(p-1) \pmod e$
3.  $ed_q \equiv 1 + k_q(q-1) \pmod e \implies 0 \equiv 1 + k_q(q-1) \pmod e$

从 (2) 和 (3) 中，我们可以解出 $(p-1)$ 和 $(q-1)$：
$$p-1 \equiv -k_p^{-1} \pmod e$$
$$q-1 \equiv -k_q^{-1} \pmod e$$
将这两个关系代入 (1) 中：
$$0 \equiv 1 + k(-k_p^{-1})(-k_q^{-1}) \pmod e$$
$$-1 \equiv k \cdot (k_p k_q)^{-1} \pmod e$$
两边同乘 $k_p k_q$ 再移项，得到 $k_p, k_q$ 的第一个关系式：
$$k_p k_q \equiv -k \pmod e$$
接下来，我们从 $ed = 1 + k(n - p - q + 1)$ 这个等式出发，同样在模 $e$ 下进行：
$$0 \equiv 1 + k(n - (p-1) - (q-1) - 1) \pmod e$$
$$0 \equiv 1 + k(n-1) - k(p-1) - k(q-1) \pmod e$$
将 $p-1 \equiv -k_p^{-1}$ 和 $q-1 \equiv -k_q^{-1}$ 代入：
$$0 \equiv 1 + k(n-1) - k(-k_p^{-1}) - k(-k_q^{-1}) \pmod e$$
$$0 \equiv 1 + k(n-1) + k \cdot k_p^{-1} + k \cdot k_q^{-1} \pmod e$$
利用 $k \equiv -k_p k_q \pmod e$ 进行代换：
$$0 \equiv 1 + k(n-1) - k_p k_q(k_p^{-1} + k_q^{-1}) \pmod e$$
$$0 \equiv 1 + k(n-1) - (k_q + k_p) \pmod e$$
整理后得到 $k_p, k_q$ 的第二个关系式：
$$k_p + k_q \equiv k(n-1) + 1 \pmod e$$
现在我们拥有了关于 $k_p$ 和 $k_q$ 的一个方程组（韦达定理的形式）。它们是二次方程 $x^2 - (k_p+k_q)x + k_p k_q = 0 \pmod e$ 的两个根。
代入我们已知的 $k, n, e$，构造多项式：
$$f(x) = x^2 - (k(n-1)+1)x - k \pmod e$$
使用 SageMath 的 `f.roots()` 求解该方程，得到两个根：**`64743` 和 `30590`**。这两个值就是 $k_p$ 和 $k_q$（顺序待定）。

### **第四步：从低位开始的深度优先搜索 (DFS)**

现在，所有的未知整数 $k, k_p, k_q$ 都已确定。我们可以利用之前建立的四个核心方程，从最低位开始，逐位恢复 `p, q, d, dp, dq` 的所有未知比特。

**核心思想**：
如果一个等式成立，那么它在模 $2^h$ 的意义下也必然成立。
我们从 $h=1$（最低位）开始，逐步增加 $h$。在第 $h$ 步，我们尝试猜测 `p, q, d, dp, dq` 在第 $h$ 位的比特（0 或 1），并检查是否满足以下所有四个同余方程：
$$
\begin{cases}
pq \equiv n \pmod{2^h} \\
ed \equiv 1 + k(n - p - q + 1) \pmod{2^h} \\
ed_p \equiv 1 + k_p(p-1) \pmod{2^h} \\
ed_q \equiv 1 + k_q(q-1) \pmod{2^h}
\end{cases}
$$
* 如果所有方程都满足，说明这一位的猜测是**可能正确**的，我们继续递归到下一位 $(h+1)$。
* 如果任何一个方程不满足，说明这一位的猜测是**错误**的，立刻**剪枝**，回溯到上一位尝试其他组合。

由于低位的已知比特较多，搜索树在早期阶段会被大量剪枝，效率很高。

### **第五步：Coppersmith 方法**

DFS 在低位恢复时非常有效，但随着位数的增高（`h` 增大），已知的比特变得稀疏，剪枝效果急剧下降，搜索会变得非常缓慢。

当 DFS 运行到约 700 位时，我们已经恢复了 `p` 的**连续 700 个低位比特**。这是一个非常强的条件，足以让我们切换到更强大的武器——**Coppersmith's Method**。

该方法可以在已知一个大数 $N$ 的一个因子 $p$ 的部分比特时，有效地恢复出完整的 $p$。

1.  **问题建模**：
    我们已知 $p$ 的低 700 位，记为 $p_{low}$。设 $p$ 的高位部分为未知数 $x$。那么 $p$ 可以表示为：
    $$p = x \cdot 2^{700} + p_{low}$$
    我们知道 $p$ 是 $n$ 的一个因子，所以 $f(x) = x \cdot 2^{700} + p_{low}$ 是一个在模 $p$ 意义下有根 $x$ 的多项式。Coppersmith 攻击允许我们在模 $n$ 的意义下找到这个“小根” $x$。

2.  **求解**：
    使用 SageMath 的 `f.small_roots(X, beta)` 函数，设置 $X$ 为 $x$ 的可能上限（$2^{1024-700}$），$\beta$ 为 1（因为我们确定 $p$ 是一个因子）。
    求解后得到 $x$ 的值，从而重构出完整的 `p`。

### **第六步：重建密钥与计算 Flag**

1.  **计算所有参数**：
    * 有了 `p`，立刻计算 `q = n // p`。
    * 有了 `p` 和 `q`，计算 `phi = (p-1)*(q-1)`。
    * 计算 `d = inverse(e, phi)`。
    * 计算 `dp = d % (p-1)`，`dq = d % (q-1)`。
    * 计算 `qinvp = inverse(q, p)`。

2.  **重建 PEM 文件**：
    使用 `Crypto.PublicKey.RSA.construct` 函数，将 `(n, e, d, p, q)` 等所有参数传入，构建一个 RSA 密钥对象。然后使用 `exportKey()` 方法生成标准的 PEM 格式私钥。

3.  **计算 Flag**：
    注意题目环境是 Linux，因此行尾符是 `\n` 而非 Windows 的 `\r\n`。
    读取生成的 `privkey.pem` 文件内容，替换行尾符后，计算其 MD5 哈希值，格式化后即得到最终 flag。

**`flag{d13b8e56805cf71cb75789dda1816587}`**
