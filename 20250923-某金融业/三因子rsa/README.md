### **三素数 RSA 密钥恢复挑战解题报告**

#### **摘要**

本报告记录了一次针对三素数 RSA 密码系统的完整破解过程。挑战的初始信息包含一个 768 位的模数 $n$、一对 RSA 密钥 $(e, d)$ 的部分高位 `ek` 和 `dk`、一组用于功能验证的明文-密文对 `(m, c)`，以及一个使用固定公钥 $e_2=7$ 加密的 Flag。

我的解题思路是一个多阶段的密码分析与工程优化过程。首先，我利用已知的 `(m, c)` 对构造了两个离散对数问题 (DLP)，并使用大步小步算法 (BSGS) 成功恢复了密钥 `d` 和 `e` 的完整值。随后，在拥有完整密钥对后，我通过一个基于 Miller-Rabin 思想的算法快速分解了模数 $n$。在最后的解密阶段，由于标准 RSA 解密失效，我转而使用中国剩余定理 (CRT)，通过并行验证多个候选解的方式成功还原了 Flag。为了提升计算效率，我对整个求解脚本进行了并发优化，利用 `concurrent.futures` 模块将计算密集型任务并行化，显著缩短了运行时间。

#### **一、初步分析与密钥恢复**

挑战的突破口在于泄露的 `(m, c)` 验证对和部分密钥 `dk`, `ek`。我的目标是利用这些信息补全密钥的未知低位。

1. **恢复 `d_low`**
    我首先分析了挑战脚本生成 `test` 对的逻辑，其关系为 $c \equiv m^d \pmod n$。基于此，我将 $d$ 分解为已知的高位 `dk` 和未知的 44 位低位 $d_{low}$，即 $d = dk + d_{low}$。代入后可推导出如下离散对数问题：
    $$m^{d_{low}} \equiv c \cdot (m^{dk})^{-1} \pmod n$$
    对于这个 $2^{44}$ 规模的搜索空间，我选用了大步小步算法 (BSGS)。在最初的几次尝试中，由于对 `(m,c)` 关系的假设错误以及代码中的微小 bug，导致 BSGS 求解失败。在仔细审查了挑战逻辑并修正了数学公式后，BSGS 算法成功地求解出了 `d_low` 的值，我得以重构出完整的私钥 `d`。

2. **恢复 `e_low`**
    在成功恢复 `d` 后，我采用完全相同的思路来恢复公钥 `e`。原始脚本的验证逻辑 `m == pow(c, e, n)` 给了我们另一个关键关系：$m \equiv c^e \pmod n$。同样地，我将 $e$ 分解为 $e = ek + e_{low}$，并构造了第二个离散对数问题：
    $$c^{e_{low}} \equiv m \cdot (c^{ek})^{-1} \pmod n$$
    再次运行 BSGS 算法，我成功求解出了 `e_low`，并重构出完整的公钥 `e`。

#### **二、模数分解与最终解密**

在同时拥有完整的 `(e, d)` 密钥对后，后续的破解步骤变得非常直接。

1. **分解模数 `n`**
    我利用了 RSA 的核心性质：$k = e \cdot d - 1$ 是 $\lambda(n)$ 的倍数。对于一个 $\lambda(n)$ 的倍数 `k`，可以通过一个基于 Miller-Rabin 素性检验思想的随机算法来快速分解模数。我编写了一个 `factor_all` 函数，通过迭代调用该算法，成功将 `n` 分解为其三个 256 位的素因子 $p, q, r$。

2. **CRT 解密**
    在尝试使用标准 RSA 公式解密 Flag 时，程序因 `ValueError: base is not invertible` 而失败。我立刻意识到这是因为公钥 $e_2=7$ 与 $\lambda(n) = \text{lcm}(p-1, q-1, r-1)$ 不互质。

    为绕过此问题，我采用了中国剩余定理 (CRT)。我将解密问题分解为求解一个同余方程组。对于 `p` 和 `q`，由于它们的 $\phi$ 值与 7 互质，我可以正常求解出明文余数 $a_p$ 和 $a_q$。但对于 `r`，由于 `r-1` 是 7 的倍数，我需要直接求解 $a_r^7 \equiv \text{enc} \pmod r$，这得到了 7 个可能的 $a_r$ 值。

    最后，我将唯一的 $(a_p, a_q)$ 与 7 个不同的 $a_r$ 进行组合，构造出 7 个候选 Flag，并通过验证其格式（以 `flag{` 开头）找到了唯一正确的答案。

#### **三、性能优化与并发实现**

最初的串行脚本虽然能解决问题，但 BSGS 阶段耗时较长。为了提升效率，我对代码进行了并发优化。

* **并发模型**: 我选用了 Python 的 `concurrent.futures.ProcessPoolExecutor`，因为它通过创建多进程来规避全局解释器锁 (GIL) 的限制，能够真正利用多核 CPU 处理计算密集型任务。
* **优化策略**: 经过分析，我发现之前“并行构造，串行搜索”的 BSGS 模型存在结果合并的串行瓶颈。受 MapReduce 思想启发，我将其重构为“**串行构造，并行搜索**”的新模型：由主进程快速生成完整的 Baby Steps 哈希表，然后将计算最密集的 Giant Steps 搜索任务分发给多个子进程并行执行。这极大地减少了进程间通信开销并最大化了并行效率。
* **细节处理**: 我还解决了在 `spawn` 模式下子进程重复打印初始化日志的问题，并将最终的 CRT 候选解验证过程也进行了并行化，使整个脚本的执行流程更加高效、流畅。
